/*
 *  This file is auto generated by oeedger8r. DO NOT EDIT.
 */
#include "enc_t.h"
#include <openenclave/edger8r/enclave.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

OE_EXTERNC_BEGIN



/****** ECALL function wrappers  *************/
void ecall_ecall_TaCreateMasterEncryptionKey(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaCreateMasterEncryptionKey_args_t* pargs_in = (ecall_TaCreateMasterEncryptionKey_args_t*) input_buffer;
    ecall_TaCreateMasterEncryptionKey_args_t* pargs_out = (ecall_TaCreateMasterEncryptionKey_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaCreateMasterEncryptionKey(
        );

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_TaDestroyMasterEncryptionKey(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaDestroyMasterEncryptionKey_args_t* pargs_in = (ecall_TaDestroyMasterEncryptionKey_args_t*) input_buffer;
    ecall_TaDestroyMasterEncryptionKey_args_t* pargs_out = (ecall_TaDestroyMasterEncryptionKey_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaDestroyMasterEncryptionKey(
        );

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_TaGetRandomBytes(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaGetRandomBytes_args_t* pargs_in = (ecall_TaGetRandomBytes_args_t*) input_buffer;
    ecall_TaGetRandomBytes_args_t* pargs_out = (ecall_TaGetRandomBytes_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */
    OE_SET_OUT_POINTER(buffer, pargs_in->buffer_size);

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaGetRandomBytes(
        pargs_in->buffer,
        pargs_in->buffer_size);

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_TaEncryptData(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaEncryptData_args_t* pargs_in = (ecall_TaEncryptData_args_t*) input_buffer;
    ecall_TaEncryptData_args_t* pargs_out = (ecall_TaEncryptData_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */
    OE_SET_IN_POINTER(plaintext, pargs_in->plaintext_len);
    OE_SET_IN_POINTER(aad, pargs_in->aad_len);
    OE_SET_IN_POINTER(iv, pargs_in->iv_len);

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */
    OE_SET_OUT_POINTER(output_buffer, pargs_in->output_buffer_size);

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaEncryptData(
        (const unsigned char*) pargs_in->plaintext,
        pargs_in->plaintext_len,
        (const unsigned char*) pargs_in->aad,
        pargs_in->aad_len,
        (const unsigned char*) pargs_in->iv,
        pargs_in->iv_len,
        pargs_in->output_buffer,
        pargs_in->output_buffer_size);

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_TaDecryptData(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaDecryptData_args_t* pargs_in = (ecall_TaDecryptData_args_t*) input_buffer;
    ecall_TaDecryptData_args_t* pargs_out = (ecall_TaDecryptData_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */
    OE_SET_IN_POINTER(ciphertext_buffer, pargs_in->ciphertext_buffer_size);
    OE_SET_IN_POINTER(aad, pargs_in->aad_len);
    OE_SET_IN_POINTER(iv, pargs_in->iv_len);

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */
    OE_SET_OUT_POINTER(output_buffer, pargs_in->output_buffer_size);

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaDecryptData(
        (const unsigned char*) pargs_in->ciphertext_buffer,
        pargs_in->ciphertext_buffer_size,
        (const unsigned char*) pargs_in->aad,
        pargs_in->aad_len,
        (const unsigned char*) pargs_in->iv,
        pargs_in->iv_len,
        pargs_in->output_buffer,
        pargs_in->output_buffer_size);

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_TaSetSigningKey(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaSetSigningKey_args_t* pargs_in = (ecall_TaSetSigningKey_args_t*) input_buffer;
    ecall_TaSetSigningKey_args_t* pargs_out = (ecall_TaSetSigningKey_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */
    OE_SET_IN_POINTER(key, pargs_in->key_len);

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaSetSigningKey(
        (const unsigned char*) pargs_in->key,
        pargs_in->key_len);

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_TaSignData(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaSignData_args_t* pargs_in = (ecall_TaSignData_args_t*) input_buffer;
    ecall_TaSignData_args_t* pargs_out = (ecall_TaSignData_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */
    OE_SET_IN_POINTER(data_to_be_signed, pargs_in->data_to_be_signed_size);

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */
    OE_SET_OUT_POINTER(digest, pargs_in->digest_size);

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaSignData(
        (const unsigned char*) pargs_in->data_to_be_signed,
        pargs_in->data_to_be_signed_size,
        pargs_in->digest,
        pargs_in->digest_size);

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_TaDeriveAndSignData(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_TaDeriveAndSignData_args_t* pargs_in = (ecall_TaDeriveAndSignData_args_t*) input_buffer;
    ecall_TaDeriveAndSignData_args_t* pargs_out = (ecall_TaDeriveAndSignData_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */
    OE_SET_IN_POINTER(identity, pargs_in->identity_size);
    OE_SET_IN_POINTER(data_to_be_signed, pargs_in->data_to_be_signed_size);

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */
    OE_SET_OUT_POINTER(digest, pargs_in->digest_size);

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    pargs_out->_retval = ecall_TaDeriveAndSignData(
        (const unsigned char*) pargs_in->identity,
        pargs_in->identity_size,
        (const unsigned char*) pargs_in->data_to_be_signed,
        pargs_in->data_to_be_signed_size,
        pargs_in->digest,
        pargs_in->digest_size);

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}

void ecall_ecall_InitializeStdio(
        uint8_t* input_buffer, size_t input_buffer_size,
        uint8_t* output_buffer, size_t output_buffer_size,
        size_t* output_bytes_written)
{
    oe_result_t _result = OE_FAILURE;

    /* Prepare parameters */
    ecall_InitializeStdio_args_t* pargs_in = (ecall_InitializeStdio_args_t*) input_buffer;
    ecall_InitializeStdio_args_t* pargs_out = (ecall_InitializeStdio_args_t*) output_buffer;

    size_t input_buffer_offset = 0;
    size_t output_buffer_offset = 0;
    OE_ADD_SIZE(input_buffer_offset, sizeof(*pargs_in));
    OE_ADD_SIZE(output_buffer_offset, sizeof(*pargs_out));

    /* Make sure input and output buffers lie within the enclave */
    if (!input_buffer || !oe_is_within_enclave(input_buffer, input_buffer_size))
        goto done;

    if (!output_buffer || !oe_is_within_enclave(output_buffer, output_buffer_size))
        goto done;

    /* Set in and in-out pointers */

    /* Set out and in-out pointers. In-out parameters are copied to output buffer. */

    /* lfence after checks */
    oe_lfence();

    /* Call user function */
    ecall_InitializeStdio(
        );

    /* Success. */
    _result = OE_OK; 
    *output_bytes_written = output_buffer_offset;

done:
    if (pargs_out && output_buffer_size >= sizeof(*pargs_out)) 
        pargs_out->_result = _result;
}



/****** ECALL function table  *************/
oe_ecall_func_t __oe_ecalls_table[] = {
    (oe_ecall_func_t) ecall_ecall_TaCreateMasterEncryptionKey,
    (oe_ecall_func_t) ecall_ecall_TaDestroyMasterEncryptionKey,
    (oe_ecall_func_t) ecall_ecall_TaGetRandomBytes,
    (oe_ecall_func_t) ecall_ecall_TaEncryptData,
    (oe_ecall_func_t) ecall_ecall_TaDecryptData,
    (oe_ecall_func_t) ecall_ecall_TaSetSigningKey,
    (oe_ecall_func_t) ecall_ecall_TaSignData,
    (oe_ecall_func_t) ecall_ecall_TaDeriveAndSignData,
    (oe_ecall_func_t) ecall_ecall_InitializeStdio,
};

size_t __oe_ecalls_table_size = OE_COUNTOF(__oe_ecalls_table);


/* ocall wrappers */

oe_result_t ocall_mkdir(
        int* _retval,
        const char* dirname)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_mkdir_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.dirname = (char*) dirname;
    _args.dirname_len = (dirname) ? (strlen(dirname) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_mkdir_args_t));
    if (dirname) OE_ADD_SIZE(_input_buffer_size, _args.dirname_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_mkdir_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(dirname, _args.dirname_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_mkdir,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_GetUntrustedFileSize(
        GetUntrustedFileSize_Result* _retval,
        const char* filename)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_GetUntrustedFileSize_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.filename = (char*) filename;
    _args.filename_len = (filename) ? (strlen(filename) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_GetUntrustedFileSize_args_t));
    if (filename) OE_ADD_SIZE(_input_buffer_size, _args.filename_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_GetUntrustedFileSize_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(filename, _args.filename_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_GetUntrustedFileSize,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_GetUntrustedFileContent(
        GetUntrustedFileContent_Result* _retval,
        const char* location,
        size_t len)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_GetUntrustedFileContent_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.location = (char*) location;
    _args.location_len = (location) ? (strlen(location) + 1) : 0;
    _args.len = len;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_GetUntrustedFileContent_args_t));
    if (location) OE_ADD_SIZE(_input_buffer_size, _args.location_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_GetUntrustedFileContent_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(location, _args.location_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_GetUntrustedFileContent,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ExportFile(
        unsigned int* _retval,
        const char* filename,
        unsigned int appendToExistingFile,
        const void* content,
        size_t len)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_ExportFile_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.filename = (char*) filename;
    _args.filename_len = (filename) ? (strlen(filename) + 1) : 0;
    _args.appendToExistingFile = appendToExistingFile;
    _args.content = (void*) content;
    _args.len = len;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ExportFile_args_t));
    if (filename) OE_ADD_SIZE(_input_buffer_size, _args.filename_len * sizeof(char));
    if (content) OE_ADD_SIZE(_input_buffer_size, _args.len);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ExportFile_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(filename, _args.filename_len * sizeof(char));
    OE_WRITE_IN_PARAM(content, _args.len);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_ExportFile,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_ExportPublicCertificate(
        oe_result_t* _retval,
        const char* location,
        const void* ptr,
        size_t len)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_ExportPublicCertificate_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.location = (char*) location;
    _args.location_len = (location) ? (strlen(location) + 1) : 0;
    _args.ptr = (void*) ptr;
    _args.len = len;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_ExportPublicCertificate_args_t));
    if (location) OE_ADD_SIZE(_input_buffer_size, _args.location_len * sizeof(char));
    if (ptr) OE_ADD_SIZE(_input_buffer_size, _args.len);

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_ExportPublicCertificate_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(location, _args.location_len * sizeof(char));
    OE_WRITE_IN_PARAM(ptr, _args.len);

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_ExportPublicCertificate,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_stat64i32(
        int* _retval,
        const char* path,
        struct ocall_struct_stat64i32* buf)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_stat64i32_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.path = (char*) path;
    _args.path_len = (path) ? (strlen(path) + 1) : 0;
    _args.buf = (struct ocall_struct_stat64i32*) buf;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_stat64i32_args_t));
    if (path) OE_ADD_SIZE(_input_buffer_size, _args.path_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_stat64i32_args_t));
    if (buf) OE_ADD_SIZE(_output_buffer_size, sizeof(struct ocall_struct_stat64i32));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(path, _args.path_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_stat64i32,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;
    OE_READ_OUT_PARAM(buf, (size_t)(sizeof(struct ocall_struct_stat64i32)));

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_remove(
        int* _retval,
        const char* filename)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_remove_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.filename = (char*) filename;
    _args.filename_len = (filename) ? (strlen(filename) + 1) : 0;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_remove_args_t));
    if (filename) OE_ADD_SIZE(_input_buffer_size, _args.filename_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_remove_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(filename, _args.filename_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_remove,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_opendir(
        FindFirstUntrustedFile_Result* _retval,
        const char* filePathWithWildcards,
        uint32_t matchingFileNameSize)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_opendir_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.filePathWithWildcards = (char*) filePathWithWildcards;
    _args.filePathWithWildcards_len = (filePathWithWildcards) ? (strlen(filePathWithWildcards) + 1) : 0;
    _args.matchingFileNameSize = matchingFileNameSize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_opendir_args_t));
    if (filePathWithWildcards) OE_ADD_SIZE(_input_buffer_size, _args.filePathWithWildcards_len * sizeof(char));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_opendir_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));

    OE_WRITE_IN_PARAM(filePathWithWildcards, _args.filePathWithWildcards_len * sizeof(char));

    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_opendir,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_readdir(
        ocall_struct_dirent* _retval,
        uintptr_t findNextHandle,
        uint32_t matchingFileNameSize)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_readdir_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.findNextHandle = findNextHandle;
    _args.matchingFileNameSize = matchingFileNameSize;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_readdir_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_readdir_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_readdir,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}

oe_result_t ocall_closedir(
        oe_result_t* _retval,
        uintptr_t findNextHandle)
{
    oe_result_t _result = OE_FAILURE;

    /* Marshaling struct */ 
    ocall_closedir_args_t _args, *_pargs_in = NULL, *_pargs_out=NULL;

    /* Marshaling buffer and sizes */ 
    size_t _input_buffer_size = 0;
    size_t _output_buffer_size = 0;
    size_t _total_buffer_size = 0;
    uint8_t* _buffer = NULL;
    uint8_t* _input_buffer = NULL;
    uint8_t* _output_buffer = NULL;
    size_t _input_buffer_offset = 0;
    size_t _output_buffer_offset = 0;
    size_t _output_bytes_written = 0;

    /* Fill marshaling struct */
    memset(&_args, 0, sizeof(_args));
    _args.findNextHandle = findNextHandle;

    /* Compute input buffer size. Include in and in-out parameters. */
    OE_ADD_SIZE(_input_buffer_size, sizeof(ocall_closedir_args_t));

    /* Compute output buffer size. Include out and in-out parameters. */
    OE_ADD_SIZE(_output_buffer_size, sizeof(ocall_closedir_args_t));

    /* Allocate marshaling buffer */
    _total_buffer_size = _input_buffer_size;
    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);

    _buffer = (uint8_t*) oe_allocate_ocall_buffer(_total_buffer_size);
    _input_buffer = _buffer;
    _output_buffer = _buffer + _input_buffer_size;
    if (_buffer == NULL) { 
        _result = OE_OUT_OF_MEMORY;
        goto done;
    }

    /* Serialize buffer inputs (in and in-out parameters) */
    *(uint8_t**)&_pargs_in = _input_buffer; 
    OE_ADD_SIZE(_input_buffer_offset, sizeof(*_pargs_in));


    /* Copy args structure (now filled) to input buffer */
    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));

    /* Call host function */
    if((_result = oe_call_host_function(
                        fcn_id_ocall_closedir,
                        _input_buffer, _input_buffer_size,
                        _output_buffer, _output_buffer_size,
                         &_output_bytes_written)) != OE_OK)
        goto done;

    /* Set up output arg struct pointer*/
    *(uint8_t**)&_pargs_out = _output_buffer; 
    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));

    /* Check if the call succeeded */
    if ((_result=_pargs_out->_result) != OE_OK)
        goto done;

    /* Currently exactly _output_buffer_size bytes must be written */
    if (_output_bytes_written != _output_buffer_size) {
        _result = OE_FAILURE;
        goto done;
    }

    /* Unmarshal return value and out, in-out parameters */
    *_retval = _pargs_out->_retval;

    _result = OE_OK;
done:    
    if (_buffer)
        oe_free_ocall_buffer(_buffer);
    return _result;
}


OE_ECALL void _dummy_old_style_ecall_to_keep_loader_happy(void* arg){}

OE_EXTERNC_END
